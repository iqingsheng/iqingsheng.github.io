<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花生米的博客</title>
  
  
  <link href="https://ipxx.pro/atom.xml" rel="self"/>
  
  <link href="https://ipxx.pro/"/>
  <updated>2021-07-01T07:08:44.671Z</updated>
  <id>https://ipxx.pro/</id>
  
  <author>
    <name>花生米</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringCloud-01</title>
    <link href="https://ipxx.pro/archives/d3c36fc.html"/>
    <id>https://ipxx.pro/archives/d3c36fc.html</id>
    <published>2021-07-01T05:44:08.000Z</published>
    <updated>2021-07-01T07:08:44.671Z</updated>
    
    
    <summary type="html">SpringCloud学习</summary>
    
    
    
    <category term="SpringCloud" scheme="https://ipxx.pro/categories/SpringCloud/"/>
    
    
    <category term="Java" scheme="https://ipxx.pro/tags/Java/"/>
    
    <category term="框架" scheme="https://ipxx.pro/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java面试-Java基础</title>
    <link href="https://ipxx.pro/archives/3301a9f.html"/>
    <id>https://ipxx.pro/archives/3301a9f.html</id>
    <published>2021-06-30T10:07:16.000Z</published>
    <updated>2021-07-01T08:37:14.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点"></a>Java语言有哪些特点</h2><p>1、简单易学</p><p>2、 面向对象</p><p>3、与平台无关性</p><p>4、可靠安全</p><p>5、支持多线程</p><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p><strong>面向过程</strong>：分析解决问题的步骤，把这些步骤用函数一步步实现，在使用时一一调用，性能较高。</p><p><strong>面向对象</strong>：把构成问题的事务分解成对象，描述事务在解决问题的过程中发生的行为。面向对象有<strong>封装、继承、多态</strong>的特性，易维护、易复用、易扩展。可以设计出低耦合的系统，性能比面向过程低。</p><h2 id="八种基本数据类型的大小、以及他们的封装类"><a href="#八种基本数据类型的大小、以及他们的封装类" class="headerlink" title="八种基本数据类型的大小、以及他们的封装类"></a>八种基本数据类型的大小、以及他们的封装类</h2><table><thead><tr><th>基本类型</th><th>大小（字节）</th><th>默认值</th><th>封装类</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>(byte)0</td><td>Byte</td></tr><tr><td>short</td><td>2</td><td>(short)0</td><td>Short</td></tr><tr><td>int</td><td>4</td><td>0</td><td>Integer</td></tr><tr><td>long</td><td>8</td><td>0L</td><td>Long</td></tr><tr><td>float</td><td>4</td><td>0.0f</td><td>Float</td></tr><tr><td>double</td><td>8</td><td>0.0d</td><td>Double</td></tr><tr><td>boolean</td><td>-</td><td>false</td><td>Boolean</td></tr><tr><td>char</td><td>2</td><td>\u0000(null)</td><td>Character</td></tr></tbody></table><p>注：</p><p>1、int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦Java看到null，就知道这个引用还没有指向某个对象，在任何引用使用前，必须为其指定一个对象，否则会报错。</p><p>2、基本数据类型在声明时系统会自动给他分配空间，而引用类型声明时只是分配了引用控件，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看得见。</p><p>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32/64系统，而是指CPU硬件层面），具有高效存取的特点。</p><h2 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h2><p><strong>标识符的含义：</strong></p><p>是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。</p><p><strong>命名规则：（硬性要求）</strong></p><p>标识符可以包含英文字母，0-9的数字，$以及_</p><p>标识符不能以数字开头</p><p>标识符不是关键字</p><p><strong>命名规范：（非硬性要求）</strong></p><p>类名规范：首字母大写，后面每个单词首字母大写（大驼模式）</p><p>变量名规范：首字母小写，后面每个单词首字母大写（小驼模式）</p><p>方法名规范：同变量名</p><h2 id="instanceof关键字的作用"><a href="#instanceof关键字的作用" class="headerlink" title="instanceof关键字的作用"></a>instanceof关键字的作用</h2><p>instanceof严格来说是Java中的一个双目运算符， 用来测试一个对象是否为一个类的实例，用法为：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> result <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Class</span></code></pre><p>其中obj为一个对象，Class表示一个类或者一个接口，当obj为Class的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result都返回true，否则返回false。</p><p>注意：编译器会检查obj是否能转换成右边的Class类型，如果不能转换啧直接报错，如果不能确定类型，则通过编译具体看运行时定。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译不通过i必须是引用类型，不能是基本类型</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译不通过</span></code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer <span class="token keyword">instanceof</span><span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span><span class="token comment">//false,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回false。</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Java自动装箱与拆箱"><a href="#Java自动装箱与拆箱" class="headerlink" title="Java自动装箱与拆箱"></a>Java自动装箱与拆箱</h2><p><strong>装箱就是自动将基本数据类型装换为包装器类型（int –&gt; Integer）</strong></p><p><strong>调用方法：Integer的valueOf（int）方法</strong></p><p><strong>拆箱就是自动将包装器类型转换为基本数据类型（Integer –&gt; int）</strong></p><p><strong>调用方法：Integer的intValue方法</strong></p><p>在Java SE5之前，如果要生成一个数值为10 的Integer对象，必须这样进行：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>而现在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>面试题1：以下代码会输出什么？</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>         <span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>         <span class="token class-name">Integer</span> i3 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>         <span class="token class-name">Integer</span> i4 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3<span class="token operator">==</span>i4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">truefalse</code></pre><p>为什么会出现这样的结果呢？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需看看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token operator">-</span><span class="token number">128</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>其中IntegerCache类的实现类为：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>            <span class="token comment">// high value may be configured by property int h = 127;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Use Long.decode here to avoid invoking methods that</span>            <span class="token comment">// require Integer's autoboxing cache to be initialized</span>            <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Maximum array size is Integer.MAX_VALUE</span>            h <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    high <span class="token operator">=</span> h<span class="token punctuation">;</span>            cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>从这两段代码可以看出，在通过val方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向InterCache.cache中已经存在的对象的引用；否则创建一个新的Internet对象。</p><p>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一  个对象，而i3和i4则是分别指向不同的对象。</p><p>面试题2：以下代码输出什么？</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Double</span> i1 <span class="token operator">=</span> <span class="token number">100.0</span><span class="token punctuation">;</span>        <span class="token class-name">Double</span> i2 <span class="token operator">=</span> <span class="token number">100.0</span><span class="token punctuation">;</span>        <span class="token class-name">Double</span> i3 <span class="token operator">=</span> <span class="token number">200.0</span><span class="token punctuation">;</span>        <span class="token class-name">Double</span> i4 <span class="token operator">=</span> <span class="token number">200.0</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3<span class="token operator">==</span>i4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>运行结果：</p><pre class="language-none"><code class="language-none">false false</code></pre><p>原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>从字面上看，重写就是重新写一遍的意思，其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型（除了子类中方法的返回值是父类中方法返回值的子类时）都相同的情况下，对方法体进行修改或者重写，这就是重写，但要注意子类函数的访问修饰权限不能少于父类的。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub </span>        <span class="token class-name">Son</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// TODO Auto-generated method stub </span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello by "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>重写 总结：</strong></p><ol><li>发生在父类与子类之间</li><li>方法名，参数列表，返回类型（除了子类中方法的返回类型是父类中返回类型的子类）必须相同</li><li> 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ol><p><strong>重载（Overload）</strong></p><p>在一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<strong>不能通过返回类型是否相同来判断重载</strong>。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">Father</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"wintershii"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>重载 总结：</strong></p><ol><li>重载Overload是一个类中多态性的一种表现</li><li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li><li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li></ol><h2 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h2><p><strong>==：</strong></p><p>== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作</p><ol><li><p>比较的是操作符两端的操作数是否是同一个对象。</p></li><li><p>两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。</p></li><li><p>比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。</p></li></ol><p><strong>equals:</strong></p><p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以 适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。</p><p><strong>总结：</strong></p><p>所有比较是否相等时，都是用equals并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null则空指针。</p><p>在阿里的代码规范中只使用equals，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查老代码使用“==”，替换成equals。</p><h2 id="Hashcode的作用"><a href="#Hashcode的作用" class="headerlink" title="Hashcode的作用"></a>Hashcode的作用</h2><p>java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中  插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法  就会比较满。</p><p>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。</p><p>hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合  要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。  如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了。如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p><h2 id="String、String-StringBuﬀer-和-StringBuilder-的区别是什么"><a href="#String、String-StringBuﬀer-和-StringBuilder-的区别是什么" class="headerlink" title="String、String  StringBuﬀer 和 StringBuilder 的区别是什么?"></a>String、String  StringBuﬀer 和 StringBuilder 的区别是什么?</h2><p>String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个ﬁnal类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的String对象。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>每次+操作 ：隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼接+后面的字符</p><p>StringBuﬀer和StringBuilder他们两都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">/*** The value is used for character storage.*/</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span></code></pre><p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuﬀer和StringBuilder来进行操作。另外StringBuﬀer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><h2 id="ArrayList和linkedList的区别"><a href="#ArrayList和linkedList的区别" class="headerlink" title="ArrayList和linkedList的区别"></a>ArrayList和linkedList的区别</h2><p><strong>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。</strong></p><p>Array获取数据的时间复杂度是O(1)，但是要删除数据却是开销很大，因为这需要重排数组中的所有数据。(因为删除数据以后, 需要把后面所有的数据前移)</p><p><strong>缺点：</strong>数组初始化必须指定初始化的长度, 否则报错</p><p>例如：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//推荐使用int[] 这种方式初始化</span><span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">56</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//长度：4，索引范围：[0,3]</span></code></pre><p><strong>List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。 List有两个重要的实现类：ArrayList和LinkedList</strong></p><p><strong>ArrayList:</strong> <strong>可以看作是能够自动增长容量的数组</strong></p><p><strong>ArrayList的toArray方法返回一个数组</strong></p><p><strong>ArrayList的asList方法返回一个列表</strong></p><p>ArrayList底层的实现是Array, 数组扩容实现</p><p><strong>LinkList是一个双链表，在添加和删除元素时具有比ArrayList更好的性能。但在get与set方面弱于ArrayList。当然，这些对比都是指数据量很大或者操作很频繁。</strong></p><h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><p><strong>1、两者父类不同</strong></p><p>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</p><p><strong>2、对外提供的接口不同</strong></p><p>Hashtable比HashMap多提供了elments()和contains() 两个方法。</p><p>elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。</p><p>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。</p><p><strong>3、对null的支持不同</strong></p><p>Hashtable: key和value都不能为null。</p><p>HashMap: key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性。可以有多个key值对应的value为null。</p><p><strong>4、安全性不同</strong></p><p>HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。</p><p>Hashtable是线程安全的，它的每个方法上都有synchronized关键字，因此可直接用于多线程中。</p><p>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。</p><p>ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。</p><p><strong>5、初始容量大小和每次扩充容量大小不同</strong></p><p><strong>6、计算hash值的方法不同</strong></p><h2 id="Collection包结构，与Collections的区别"><a href="#Collection包结构，与Collections的区别" class="headerlink" title="Collection包结构，与Collections的区别"></a>Collection包结构，与Collections的区别</h2><p>Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、Set。</p><p>Collections是集合类的一个帮助类，它包含有各种有关集合操作的静态多态方法，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p><h2 id="Java的四种引用，强弱软虚"><a href="#Java的四种引用，强弱软虚" class="headerlink" title="Java的四种引用，强弱软虚"></a>Java的四种引用，强弱软虚</h2><ul><li><p>强引用</p><p>强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方  式：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>软引用</p><p>软引用在程序内存不足时，会被回收，使用方式：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span><span class="token comment">// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T</span><span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> wrf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。</p></li><li><p>弱引用</p><p>弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> wrf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可用场景： Java源码中的java.util.WeakHashMap中的key就是使用弱引用，我的理解就是， 一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p></li><li><p>虚引用</p><p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入ReferenceQueue中。注意哦，其它引用是被JVM回收后才被传入ReferenceQueue中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有ReferenceQueue，使用例子：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> prf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可用场景：对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效</p></li></ul><p><strong>上诉所说的几类引用，都是指对象本身的引用，而不是指Reference的四个子类的引用(SoftReference等)</strong></p><h2 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h2><p>泛型是Java SE 1.5之后的特性，《Java核心技术》中对泛型的定义是：</p><blockquote><p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。</p></blockquote><p>“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer、String、自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> iniData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span></code></pre><p>使用泛型的好处？</p><p>以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p><h2 id="Java创建对象有几种方式？"><a href="#Java创建对象有几种方式？" class="headerlink" title="Java创建对象有几种方式？"></a>Java创建对象有几种方式？</h2><p>java中提供了以下四种创建对象的方式:</p><ul><li>new创建新对象</li><li>通过反射机制</li><li>采用clone机制</li><li>通过序列化机制</li></ul><h2 id="有没有可能两个不相等的对象有相同的hashcode"><a href="#有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="有没有可能两个不相等的对象有相同的hashcode"></a>有没有可能两个不相等的对象有相同的hashcode</h2><p>有可能，在产生hash冲突时，两个不相等的对象就会有相同的 hashcode 值。当hash冲突产生时，一般有以下几种方式来处理：</p><ul><li>拉链法：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储。</li><li>开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li><li>再哈希：又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个……等哈希函数计算地址，直到无冲突。</li></ul><h2 id="深拷贝和浅拷贝的区别是什么"><a href="#深拷贝和浅拷贝的区别是什么" class="headerlink" title="深拷贝和浅拷贝的区别是什么?"></a>深拷贝和浅拷贝的区别是什么?</h2><ul><li>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</li><li>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制到的新对象，而不再是原有的那些被引用的对象.换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</li></ul><h2 id="ﬁnal有哪些用法"><a href="#ﬁnal有哪些用法" class="headerlink" title="ﬁnal有哪些用法?"></a>ﬁnal有哪些用法?</h2><ul><li>被ﬁnal修饰的类不可以被继承</li><li>被ﬁnal修饰的方法不可以被重写</li><li>被ﬁnal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</li><li>被ﬁnal修饰的方法,JVM会尝试将其内联,以提高运行效率</li><li>被ﬁnal修饰的常量,在编译阶段会存入常量池中</li></ul><h2 id="static都有哪些用法"><a href="#static都有哪些用法" class="headerlink" title="static都有哪些用法?"></a>static都有哪些用法?</h2><p>所有的人都知道static关键字这两个基本的用法：静态变量和静态方法。也就是被static所修饰的变量/方法都属于类的静态资源，类实例所共享。</p><p>除了静态变量和静态方法之外，static也用于静态块，多用于初始化操作：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> calss     <span class="token class-name">PreCache</span><span class="token punctuation">&#123;</span> <span class="token keyword">static</span><span class="token punctuation">&#123;</span><span class="token comment">//执行相关操作</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>此外static也多用于修饰内部类，此时称之为静态内部类。</p><p>最后一种用法就是静态导包，即import static。import static是在JDK 1.5之后引入的新特性，可以用来指定导入某个类中的静态资源，并且不需要使用类名，可以直接使用资源名，比如：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Math</span><span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//System.out.println(Math.sin(20));传统做法</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="3-0-1-0-3返回值是什么"><a href="#3-0-1-0-3返回值是什么" class="headerlink" title="3 * 0.1 == 0.3返回值是什么"></a>3 * 0.1 == 0.3返回值是什么</h2><p>false，因为有些浮点数不能完全精确的表示出来。</p><h2 id="a-a-b与a-b有什么区别吗"><a href="#a-a-b与a-b有什么区别吗" class="headerlink" title="a=a+b与a+=b有什么区别吗?"></a>a=a+b与a+=b有什么区别吗?</h2><p>+=操作符会进行隐式自动类型转换，此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型，而a=a+b则不会自动进行类型转换，如：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> a <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment">// 报编译错误:cannot convert from int to byte</span>b <span class="token operator">+=</span> a<span class="token punctuation">;</span></code></pre><p>以下代码是否有错，有的话怎么改?</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">short</span> s1<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> s1 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>有错误，short类型在进行运算时会自动提升为int类型，也就是说 s1+1 的运算结果是int类型，而s1是short 类型，此时编译器会报错.</p><p>正确写法：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">short</span> s1<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>s1 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>+=操作符会对右边的表达式结果强转匹配左边的数据类型，所以没错。</p><h2 id="try-catch-ﬁnally，try里有return，ﬁnally还执行么？"><a href="#try-catch-ﬁnally，try里有return，ﬁnally还执行么？" class="headerlink" title="try catch ﬁnally，try里有return，ﬁnally还执行么？"></a>try catch ﬁnally，try里有return，ﬁnally还执行么？</h2><p>执行，并且ﬁnally的执行早于try里面的return。</p><p>结论：</p><ol><li>不管有没有出现异常，ﬁnally块中代码都会执行；</li><li>当try和catch中有return时，ﬁnally仍然会执行；</li><li>ﬁnally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管ﬁnally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在ﬁnally执行前确定的；</li><li>ﬁnally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li></ol><h2 id="Excption与Error包结构"><a href="#Excption与Error包结构" class="headerlink" title="Excption与Error包结构"></a>Excption与Error包结构</h2><p>Java可抛出(Throwable)的结构分为三种类型：被检查的异常(CheckedException)，运行时异常(RuntimeException)，错误(Error)。</p><p><strong>1、运行时异常</strong></p><p>定义：RuntimeException及其子类都被称为运行时异常。</p><p>特点：Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fast机制产生的ConcurrentModiﬁcationException异常（java.util包下面的所有的集合类都是快速失败的，“快速失  败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModiﬁcationException 异常，从而产生fail-fast机制，这个错叫并发修改异常。Fail-safe，java.util.concurrent包下面的所有的类都是安全失败的，在遍历过程中，如果已经遍历的数组上的内容 变化了，迭代器不会抛出ConcurrentModiﬁcationException异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器弱一致的表现。ConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样了。）等，都属于运行时异常。</p><p>常见的五种运行时异常：</p><p>ClassCastException（ 类转换异常 ） </p><p>IndexOutOfBoundsException（数组越界）</p><p>NullPointerException（空指针异常）</p><p>ArrayStoreException（数据存储异常，操作数组是类型不一致） </p><p>BuﬀerOverﬂowException</p><p><strong>2、被检查异常</strong></p><p>定义：Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。</p><p>特点 ：Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。被检查异常通常都是可以恢复的。</p><p>如：</p><p>IOException </p><p>FileNotFoundException</p><p>SQLException</p><p>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的FileNotFoundException。然而，不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的NullPointerException。</p><p><strong>3、错误</strong></p><p>定义： Error类及其子类。</p><p>特点：和运行时异常一样，编译器也不会对错误进行检查。</p><p>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。出现这种错误会导致程序终止运行。OutOfMemoryError、ThreadDeath。</p><p>Java虚拟机规范规定JVM的内存分为了好几块，比如堆，栈，程序计数器，方法区等</p><h2 id="OOM你遇到过哪些情况，SOF你遇到过哪些情况"><a href="#OOM你遇到过哪些情况，SOF你遇到过哪些情况" class="headerlink" title="OOM你遇到过哪些情况，SOF你遇到过哪些情况"></a>OOM你遇到过哪些情况，SOF你遇到过哪些情况</h2><p><strong>OOM</strong>:</p><p>1、OutOfMemoryError异常</p><p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。</p><p>Java Heap 溢出：</p><p>一般的异常信息：java.lang.OutOfMemoryError:java heap spacess。</p><p>Java对用于存储对象实例，我们只要不断的创建对象，并且保证GC  Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p><p>出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overﬂow)。</p><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过 怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。</p><p>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p><p>2，虚拟机栈和本地方法栈溢出</p><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverﬂowError异常。  如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常</p><p>这里需要注意当栈的大小越大可分配的线程数就越少。</p><p>3，运行时常量池溢出</p><p>异常信息：java.lang.OutOfMemoryError：PermGenspace</p><p>如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的  作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否  则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在  方法区内，我们可以通过-XX：PermSize和-XX：MaxPermSize限制方法区的大小，从而间接限制其中常量  池的容量。</p><p>4，方法区溢出</p><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能  是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。</p><p>异常信息：java.lang.OutOfMemoryError：PermGenspace</p><p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在 经常动态生成大量Class的应用中，要特别注意这点。</p><h4 id="SOF（堆栈溢出StackOverﬂow）："><a href="#SOF（堆栈溢出StackOverﬂow）：" class="headerlink" title="SOF（堆栈溢出StackOverﬂow）："></a>SOF（堆栈溢出StackOverﬂow）：</h4><p>StackOverﬂowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p><p>因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量  超过1m而导致溢出。</p><p>栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大。</p>]]></content>
    
    
    <summary type="html">Java面试题基础部分</summary>
    
    
    
    <category term="面试题" scheme="https://ipxx.pro/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java" scheme="https://ipxx.pro/tags/Java/"/>
    
    <category term="面试" scheme="https://ipxx.pro/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM&amp;Java虚拟机</title>
    <link href="https://ipxx.pro/archives/6037eeb8.html"/>
    <id>https://ipxx.pro/archives/6037eeb8.html</id>
    <published>2021-06-30T01:44:57.000Z</published>
    <updated>2021-06-30T09:39:45.244Z</updated>
    
    
    
    
    <category term="Java" scheme="https://ipxx.pro/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ipxx.pro/tags/Java/"/>
    
    <category term="JVM" scheme="https://ipxx.pro/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>博客备份</title>
    <link href="https://ipxx.pro/archives/34169.html"/>
    <id>https://ipxx.pro/archives/34169.html</id>
    <published>2021-06-29T03:16:10.000Z</published>
    <updated>2021-06-30T06:36:38.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><h3 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h3><p>打开自己的github里存放博文页面文件的仓库（确保已有主分支），建立一个新的分支hexo，并将其设置为默认分支。</p><p><img src="https://cdn.jsdelivr.net/gh/nzgong/IMG/20210629112623.png"></p><p>本地的博客原始目录里只有.deploy_git文件（里面存放的是上传到博客仓库的页面文件），并没有.git文件，所以要先在其他地方新建空目录，将仓库的hexo分支clone下来，再将里面的.git文件复制到本地的博客目录中。</p><p><img src="https://cdn.jsdelivr.net/gh/nzgong/IMG/20210629113040.png"></p><p>检查主题文件下有没有克隆时产生的.git文件，有的话要删掉，因为git不能嵌套上传，会导致主题文件无法上传，备份出问题。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>在博客根目录下执行如下命令</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>$ <span class="token function">git</span> commit -m <span class="token string">"备份"</span>$ <span class="token function">git</span> push origin hexo</code></pre><h3 id="日常更新命令"><a href="#日常更新命令" class="headerlink" title="日常更新命令"></a>日常更新命令</h3><pre class="language-bash" data-language="bash"><code class="language-bash">hexo clean<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit -m <span class="token string">"备份"</span><span class="token function">git</span> pushhexo ghexo d</code></pre><h2 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h2><h3 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/yourgithubname/yourgithubname.github.io</code></pre><h3 id="恢复博客-1"><a href="#恢复博客-1" class="headerlink" title="恢复博客"></a>恢复博客</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-cli$ <span class="token function">npm</span> <span class="token function">install</span>$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git</code></pre>]]></content>
    
    
    <summary type="html">博客搭建后的备份操作</summary>
    
    
    
    <category term="博客搭建" scheme="https://ipxx.pro/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="博客" scheme="https://ipxx.pro/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="备份" scheme="https://ipxx.pro/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
</feed>
